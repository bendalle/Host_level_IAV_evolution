---
title: "Summary statistics"
author: "JT McCrone"
date: "3/22/2017"
output: github_document
---
```{r,echo=F}
require(knitr)
require(ggplot2)
require(magrittr)
require(tidyverse)
require(plyr)
require(reshape2)
require(extrafont)
require(wesanderson)

set.seed(42) # Set seed so randomization is reproducible
opts_chunk$set(fig.align="center",warning=FALSE,tidy=T,cache = T,echo=F)
theme_set(new = theme_classic()+ theme(
axis.line.x = element_line(colour = 'black', size=0.5, linetype='solid'),
axis.line.y = element_line(colour ='black',size=0.5,linetype='solid'),
text=element_text(family="Arial",size = 18))) # to make nice plots
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
cbPalette<-wes_palette("Zissou")
source("../scripts/useful_functions.R")

```

First we'll read in the all_meta file. Which now contains every sample we ever touched. We will filter it so that it contains 1 entry per person. This handels the cases in  2014-2015 where we have mulitple samples/ person. Although the multiple samples are important when we pick which sample to use in looking at transmission, here we just are looking at dates on onset so one sample/ person will do.

When there are 2 samples we pick the one we sequenced unless we sequenced both then we take the one that qualified for snv identification with the titer as a tie braker. If we didn't sequence either sample we pick the one to include randomly. 

I should note we are taking one sample per person per infecting strain. There are cases where one person was sick twice in a season with H1N1 and H3N2. Those each counted in the meta_one. The pcr_result is used to identify transmission pairs later.

### Cohort stats

How many H3N2 and H1N1 did we sequence

```{r}
meta<-read.csv("../data/reference/all_meta.sequence_success.csv",colClasses = c('onset'='Date','collect'='Date'),stringsAsFactors = F)
meta$pcr_result[meta$pcr_result=="H3N2"]<-"A/H3N2"
meta$pcr_result[meta$pcr_result=="A/H3N3 & B/YAM"] <-"A/H3N2" # this one didn't qualify for iSNV identification
meta$season[meta$season=="10-11"]<-"2010-2011"
meta$season[meta$season=="11-12"]<-"2011-2012"
meta$season[meta$season=="12-13"]<-"2012-2013"
meta$season[meta$season=="13-14"]<-"2013-2014"

meta %>% subset(pcr_result=="A/H3N2") %>%
  .$ENROLLID  %>% unique() %>% length()->H3N2_cases


meta %>% subset(pcr_result=="A/H1N1") %>%
  .$ENROLLID  %>% unique() %>% length()->H1N1_cases

meta %>% subset(season=="2014-2015") %>%
  .$ENROLLID  %>% unique() %>% length()->cases_2014_15


write_to_summary("H3N2 cases:",H3N2_cases)
write_to_summary("H1N1 cases:",H1N1_cases)
write_to_summary("2014-2015 cases:",cases_2014_15)
```

### Table 1 stats

```{r}
meta %>% group_by(season,pcr_result) %>% dplyr::summarise(count = length(unique(ENROLLID))) ->IAV_positive_individuals


IAV_positive_individuals %>% spread(season,count)->IAV_positive_individuals.table

knitr::kable(IAV_positive_individuals.table)
```


### Transmission rules. 

These apply to all cases where 2 individuals are sick within the same household within a week of eachtoher (difference in date of onset <= 7 days).

In the event of multiple possible donors we assume the donor is the individual with symptom onset neast to the recipeient.

The donor and recipeint are never have symptoms on the same day unless they are the only cases in the house. In this case we will randomize the pair and estimate a bottleneck both ways.

If there are two possible donors with the same date of onset then we throw out any possible pair to that recipient.

Also we require that pairs have an L1-norm below the 5% percentile of the non household pairs.

```{r}
meta_one<-ddply(meta,~ENROLLID+pcr_result,function(x){ #  one per person
                                          if(nrow(x)==1){ # if there is only one sample then we are done
                                            return(x)
                                          }else if(nrow(x)==2){ # There are two samples here with this person and pcr result
                                            pick<-which(x$sequenced==T) # pick the one that we sequenced
                                            if(length(pick)==1){ #if there is only one then we're done
                                              return(x[pick,])
                                            }
                                            else if(length(pick)<1){ # we didn't sequence any of these
                                              pick<-runif(1)<0.5
                                              return(x[pick+1,]) # 1 or 2 randomly Pick is 0 or 1
                                            }
                                            else if(length(pick)>1){ # we sequenced both
                                              pick<-which(x$snv_qualified==T) # See how many qualified for snv calling
                                              if(length(pick)>1| length(pick)<1){ # Either 0 or 2 did
                                              pick<-which(x$gc_ul==max(x$gc_ul)) # take the one with a higher titer.
                                              }
                                              return(x[pick,])
                                            }
                                            
                                          }else{
                                            stop("more than 2 samples for this person?")
                                          }
})

write.csv(x = meta_one,file = "../data/reference/meta_one.seqeunce.success.csv")

meta %>% subset(snv_qualified==T)%>% nrow()->snv_qual_isolates
meta %>% subset(snv_qualified==T)%>% 
  .$ENROLLID %>% unique()%>%length()->snv_qual_individuals

write_to_summary("High quality isolates:",snv_qual_isolates)
write_to_summary("High quality individuals:",snv_qual_individuals)

```

Tranmission pairs are cases where 2 people are sick with the same strain from the same household with 7 days of eachother (inclusive)

```{r,all}
getting_tp<-function(df){ # The data frame is all for 1 house
  house<-unique(df$HOUSE_ID)
  stopifnot(length(house)==1,length(unique(df$pcr_result))==1) # Verify only 1 house here and only 1 strain
  
  if(length(unique(df$ENROLLID))>1){ # verify more than 1 person in the household
    pairs<-data.frame(ENROLLID.1=NA,ENROLLID.2=NA,onset.1=NA,onset.2=NA,transmission=NA,sequenced.1=NA,sequenced.2=NA,gc_ul.1=NA,gc_ul.2=NA,snv_qualified.1=NA,snv_qualified.2=NA)
    df<-df[order(df$onset,df$ENROLLID,decreasing = F),] # Order the data frame based on onset date. Earliest is first 
    # loop through and get all possible transmission pairs and make 1 row for each possible transmission pair
    for(i in 1:(nrow(df)-1)){
      ENROLLID.1=df$ENROLLID[i]
      onset.1=df$onset[i]
      sequenced.1=df$sequenced[i]
      gc_ul.1=df$gc_ul[i]
      snv_qualified.1=df$snv_qualified[i]
      for(j in (i+1):nrow(df)){
        ENROLLID.2=df$ENROLLID[j]
        onset.2=df$onset[j]
        sequenced.2=df$sequenced[j]
        gc_ul.2=df$gc_ul[j]
        snv_qualified.2=df$snv_qualified[j]
        transmission=onset.2-1
        #print(c(onset.2,onset.1))
        if((onset.2-onset.1)<=7){ #if onset is withing a week of each other
          out<-data.frame(ENROLLID.1=ENROLLID.1,ENROLLID.2=ENROLLID.2,onset.1=onset.1,onset.2=onset.2,transmission=transmission,sequenced.1=sequenced.1,sequenced.2=sequenced.2,gc_ul.1=gc_ul.1,gc_ul.2=gc_ul.2,snv_qualified.1=snv_qualified.1,snv_qualified.2=snv_qualified.2)
          pairs<-rbind(subset(pairs,!(is.na(ENROLLID.1))),out)# We don't want that first line with the NA  
        }
      }
    }
      return(subset(pairs,!(is.na(ENROLLID.1)))) 
  } 
}

## Add a column for valid pairs - ie pairs that match our criteria.
# This is a mess of a block of code. 

finding_valid<-function(house){ # This function will take in a household and update the valid column for each pair
  stopifnot(length(unique(house$HOUSE_ID))==1)
  house$valid=F # They all start invalid - they must prove their worth to us!
  house$double=F
  min_onset<-min(house$onset.1) # This the index date for the house it is used later
  if(length(unique(house$pair_id))==1){ # there is only one pair here so it's valid
    house$valid=T
    if(house$onset.1==house$onset.2){ # there is only one pair and they are sick on the same day so this is valid but we will need to look at transmission both ways
      house$double=T
    }
    return(house)
  }
  else{# There are multiple possible pairs here
    # If the onset days are the same now then they stay invalid.
    # All that is left is to remove the pairs that skip an individual - arc over the top.
    # For this we will look at each recipeint and validate the pair that has the minimum diff in onset date
    # but whose difference is >0
    house_multi=ddply(house,~ENROLLID.2,function(x,min_onset){ # for each possible recipient in the house we will find which donor is valid
      x=mutate(x,diff_onset=x$onset.2-x$onset.1) # Get the difference in onset date 
      valid_onsets=x$diff_onset[x$diff_onset>0] # valid pairs at this point must have a difference on onset date >0
      if(identical(x$onset.1,x$onset.2) & all(x$onset.2 == min_onset)){ # the recipient is sick on the house index case and onset1==onset2 and there is no other possible donor date - these are all sick on the first day and need to be handeled in both directions
        x$valid<-T
        x$double<-T
      }
      else if(length(valid_onsets)>0){ # There are some valid donors
        if(length(which(x$diff_onset==min(valid_onsets)))==1){ # If there is only 1 valid donor here (i.e donors not sick on the same day) 
          
        x$valid[x$diff_onset==min(valid_onsets)]=T 
        }
      }  
        # otherwise we leave them as false
        
      x<-subset(x,select=-c(diff_onset)) # get rid of this column
      return(x)
      },min_onset)
    
    return(house_multi)

    }
  }
all_pairs.tp<-ddply(meta_one,~HOUSE_ID+season+pcr_result,getting_tp)
all_pairs.tp$pair_id<-1:nrow(all_pairs.tp)


all_pairs.tp<-ddply(all_pairs.tp,~HOUSE_ID,finding_valid)

valid_pairs<-subset(all_pairs.tp,valid==T)
all_pairs.tp<-mutate(all_pairs.tp,
                     sequenced_pair=sequenced.1==sequenced.2 & sequenced.2==T, titer_pair= sequenced.1==sequenced.2 & sequenced.2==T & gc_ul.1>1e3 & gc_ul.2>1e3,snv_qualified_pair = snv_qualified.1==T & snv_qualified.2==T) # Just adding columns to summarize the pairs.



all_pairs.tp %>% .$HOUSE_ID %>% unique() %>% length()->concurrent_houses #houses with multiple infections

write_to_summary("Putative transmission events:",nrow(valid_pairs))
write_to_summary("Households with concurrent infection:",concurrent_houses )
```

This yields `r nrow(all_pairs.tp)` possible pairs. And `r nrow(valid_pairs)` valid pairs




## Summary table 
```{r,summary_table}
require(plyr)
sum.table<-function(data,r=F){
  sum.long<-ddply(data,~season+pcr_result,summarize,houses=length(unique(HOUSE_ID)),pairs=length(ENROLLID.1)) # each row is a pair
  pairs<-dcast(sum.long,season~pcr_result,value.var = "pairs",fill=0)
  pairs$total<-pairs$`A/H1N1`+pairs$`A/H3N2`
  totals<-data.frame(season="total",H1N1=sum(pairs$`A/H1N1`),H3N2=sum(pairs$`A/H3N2`),total=sum(pairs$`A/H1N1`)+sum(pairs$`A/H3N2`))
  names(totals)<-c("season","A/H1N1","A/H3N2","total")
  pairs<-rbind(pairs,totals)
  #print(kable(pairs))
  if(r==T){
    return(pairs)
  }
}
all.sum<-sum.table(valid_pairs,r=T)
```

However, we did not sequence every sample and every sample we sequenced did not yeild usable SNV data. We handeled `r nrow(meta)` samples. We sequenced `r nrow(subset(meta,sequenced==T))` samples or `r round(nrow(subset(meta,sequenced==T))/nrow(meta),2)*100`% of the samples. `r nrow(subset(meta,sequenced==T & gc_ul>1e3))` samples (`r round(nrow(subset(meta,sequenced==T & gc_ul>1e3))/nrow(meta),2)*100`%) had titers > 1000 genomes/ul and were sequenced. 

We had samples from `r length(unique(meta_one$ENROLLID))` inidividuals. We sequenced samples from `r nrow(subset(meta_one,sequenced==T))` or `r round(nrow(subset(meta_one,sequenced==T))/nrow(meta_one),2)*100`% of the individuals. 


```{r}
sequenced_pairs<-subset(valid_pairs,sequenced.1==sequenced.2 & sequenced.2==T) # both samples were sequenced.
```


So the best we could hope for would be `r nrow(sequenced_pairs)`

```{r}
sequenced.sum<-sum.table(sequenced_pairs,r=T)
```



```{r}
snv_hopefull_pairs<-subset(valid_pairs,sequenced.1==sequenced.2 & sequenced.2==T & gc_ul.1>1e3 & gc_ul.2>1e3) # Both pairs sequenced and high enough titers to look for snv
```

When we further restrict our analysis and require both samples to be greater than 10^3^ then we have `r nrow(snv_hopefull_pairs)` possible pairs. The 71 I quoted earlier included sequenced early samples and all 2014-2015 samples we handeled. I have remade the meta data csv for this analysis.

```{r}
snv_hopeful.sum<-sum.table(snv_hopefull_pairs,r=T)
```

```{r}

snv_pairs<-subset(valid_pairs,snv_qualified.1==T & snv_qualified.2==T) # Both samples sequenced with titers>1e3 and passed sequencing (ave cov >1000 in both duplicates if applicable)
snv.sum<-sum.table(snv_pairs,r=T)

write_to_summary("High quality transmission pairs:",
                 snv.sum$total[snv.sum$season=="total"])
```

## L1-norm

```{r}
qual<-read.csv("../data/processed/qual.snv.csv",colClasses = c('onset'='Date','collect'='Date'),stringsAsFactors = F) # read in quality variant calls from all seasons
qual$season[qual$season=="10-11"]<-"2010-2011"
qual$season[qual$season=="11-12"]<-"2011-2012"
qual$season[qual$season=="12-13"]<-"2012-2013"
qual$season[qual$season=="13-14"]<-"2013-2014"
```

```{r}

dist_tp<-function(pairs,qual_data){ 
  data.df<-get_freqs(pairs = pairs,snv = qual_data)
  y<-as.matrix(cbind(data.df$freq1,data.df$freq2)) 
  d=dist(t(y),method = "manhattan")
  if(is.na(d) & nrow(data.df)==1){
    if(is.na(data.df$mutation)){# This is the case when there are no variants found in either sample
    d=0
    }
  }  
  #print(paste(pairs,d,sep=":"))
  return(d)
  # This is the same as L1-norm I checked it by hand (1/18/17)
} # data frame of 1 pair

```

```{r}
#make all possible pairs comparisions

all_possible_pairs<-ddply(subset(meta_one,snv_qualified==T),~season+pcr_result,function(x) expand.grid(x$SPECID,x$SPECID)) # there is only 1 SPECID/ ERNOLLID in meta_one
names(all_possible_pairs)<-c("season","pcr_result","SPECID.1","SPECID.2")
all_possible_pairs<-subset(all_possible_pairs,SPECID.1!=SPECID.2 & SPECID.1 %in% meta_one$SPECID[meta_one$snv_qualified==T] & SPECID.2 %in% meta_one$SPECID[meta_one$snv_qualified==T] ) # This ensures that 1) we are not comparing a sample against itself and 2) both samples were well sequenced and had a chance of calling variants.

## One of the draw backs of expand grid is we get all possibilitys so there are 2 pairs for each
# combination of specid (bidirectional). We only want 1.

# This requires that the second sample was taken from the person who was sick second. This matches how we
# Set pairs in tranmission. the EnrollID is the tie-braker.

# First we need to add the necessary columns
all_possible_pairs<-mutate(all_possible_pairs,
                            ENROLLID.1=meta_one$ENROLLID[match(x = SPECID.1,meta_one$SPECID)],
                            ENROLLID.2=meta_one$ENROLLID[match(x = SPECID.2,meta_one$SPECID)],
                           time_onset=meta_one$onset[match(x = SPECID.2,meta_one$SPECID)]-meta_one$onset[match(SPECID.1,meta_one$SPECID)],
                           time_collect=meta_one$collect[match(x = SPECID.2,meta_one$SPECID)]-meta_one$collect[match(SPECID.1,meta_one$SPECID)]
                           )
write.csv(all_possible_pairs,"./every_possible_pair.csv")
all_possible_pairs<-subset(all_possible_pairs,time_onset>=0) # only those with SPECID.2 sick later than SPECID.1


# Now for those with a difference of 0. 
zeros_p<-subset(all_possible_pairs,time_onset==0)
zeros_pass<-adply(zeros_p,1,function(x){
  if(as.character(x$ENROLLID.1)<as.character(x$ENROLLID.2)){ # This is the tie break in the transmission pair search.
    return(x)
  }
})
fine_p<-subset(all_possible_pairs,time_onset>0)

possible_pairs<-rbind(fine_p,zeros_pass)

```

```{r}
possible_pairs.dist<-adply(possible_pairs,1,summarize,L1_norm=dist_tp(data.frame(SPECID.1=SPECID.1,SPECID.2=SPECID.2),qual_data = qual),.parallel = TRUE,.progress = "tk")
write.csv(x = possible_pairs.dist,"./possible.pairs.csv")

possible_pairs.dist<-read.csv("./possible.pairs.csv",stringsAsFactors = F)
```

```{r}
# Get the houses for each pair. 
possible_pairs.dist<-mutate(possible_pairs.dist,HOUSE_ID.1=meta_one$HOUSE_ID[match(x = SPECID.1,meta_one$SPECID)],HOUSE_ID.2=meta_one$HOUSE_ID[match(x = SPECID.2,meta_one$SPECID)],Household = HOUSE_ID.1==HOUSE_ID.2)

# Now Id the valid transmission pairs in the pairs.
possible_pairs.dist<-adply(possible_pairs.dist,1,function(x){
  x$valid_tp = x$ENROLLID.2 %in% all_pairs.tp$ENROLLID.2[which(all_pairs.tp$valid==T & all_pairs.tp$ENROLLID.1==x$ENROLLID.1)]
  return(x)
  })

#Let's make sure this is the same as above.
sum(possible_pairs.dist$valid_tp)
write.csv(possible_pairs.dist,"./possible.pairs.dist.csv")
```


```{r}
#l1norm.p_household<-ggplot(possible_pairs.dist,aes(x=L1_norm,fill=Household,y=..ncount..))+geom_histogram(color='white',binwidth = 10,boundary=0,position = 'dodge')+scale_fill_manual(name="",labels=c("Community","Household"),values = cbPalette[c(1,4)])+xlab("L1 Norm")+ylab("Count (normalized by group)")

#l1norm.p_household

cutoffs<-as.data.frame(quantile(possible_pairs.dist$L1_norm[possible_pairs.dist$Household==F],probs = seq(0,1,0.05))) # get the percentiles for the community pairs
names(cutoffs)<-"L1_norm"
cutoffs$threshold<-seq(0,1,0.05)
cutoffs<-adply(cutoffs,1,summarize,valid_pairs=nrow(possible_pairs.dist[(possible_pairs.dist$valid_tp==T & possible_pairs.dist$L1_norm<L1_norm),]))
ggplot(cutoffs,aes(y=valid_pairs,x=threshold))+geom_point()#+scale_x_continuous(breaks=cutoffs$L1_norm,labels = cutoffs$threshold)+xlab("Quantile")
kable(cutoffs)

possible_pairs.dist<-mutate(possible_pairs.dist,quality_distance=L1_norm<cutoffs$L1_norm[cutoffs$threshold==0.05])

# Add distance cut off data to all_pairs.tp

all_pairs.tp<-adply(all_pairs.tp,1,function(x){
  y<-subset(possible_pairs.dist,ENROLLID.1==x$ENROLLID.1 & ENROLLID.2==x$ENROLLID.2)
  
  if(x$snv_qualified_pair==T){ # we'll do this for all snv_qualified pairs not just the valid ones.
    stopifnot(nrow(y)==1)
      x$quality_distance = y$quality_distance
      return(x)
  }else{
    x$quality_distance=NA
    return(x)
  }

})



l1norm.p_tp<-ggplot(subset(possible_pairs.dist,valid_tp==T | Household==F),aes(x=L1_norm,fill=as.factor((valid_tp-1)*-1),y=..ncount..))+geom_histogram(color='white',binwidth = 7.5,boundary=0,position = 'dodge')+scale_fill_manual(name="",labels=c("Household transmision","Community aquired"),values = cbPalette[c(1,4)])+xlab("L1 Norm")+ylab("Normalized Count")+theme(legend.position = c(0.5,0.5))+geom_segment(aes(x=15,xend =cutoffs$L1_norm[cutoffs$threshold==0.05],y=0,yend=1),linetype=2,color=cbPalette[5],size=0.3)#geom_segment(aes(x=cutoffs$L1_norm[cutoffs$threshold==0.05],xend =cutoffs$L1_norm[cutoffs$threshold==0.05],y=0,yend=1),linetype=2,color=cbPalette[5],size=0.3)#+stat_bin(binwidth=10,boundary = 0, geom="text", aes(label=..count..), vjust=-1,size=2) #+scale_y_log10()
l1norm.p_tp

# What is the count in the highest bin?
l1norm.p_tp.b<-ggplot_build(l1norm.p_tp)
subset(l1norm.p_tp.b$data[[1]],group==1)->group1
subset(l1norm.p_tp.b$data[[1]],group==2)->group2
max(group2$count)
max(group1$count)
write_to_summary("Max household bar:",max(group1$count))
write_to_summary("Max community bar:",max(group2$count))


write.csv(subset(possible_pairs.dist,valid_tp==T | Household==F),"./Figures/data/Figure3A.csv")
print(cutoffs$L1_norm[cutoffs$threshold==0.05]) # I moved it 15 because of the bin size 
```

## Overall Summary

```{r}
get_double<-function(df){ # get the 
  if (length(unique(df$SPECID))==2 & length(unique(df$pcr_result))==1){ # There are 2 people in 2010-2014 with 2 samples but these appear to be 2 cases where the indivual was infected with H1N1 once and then later with H3N2. Bummer for them. but this pcr result criterea takes care of them
    return(df)
  }
}

all.intra<-ddply(meta,~ENROLLID,get_double) # Get those samples that come from longitundal pairs
sequenced.intra<-ddply(subset(meta,sequenced==T),~ENROLLID,get_double) # Get those samples that come from longitundal pairs

snv_hopefull.intra<-ddply(subset(meta,sequenced==T& gc_ul>1e3),~ENROLLID,get_double) # Get those samples that come from longitundal pairs

snv.intra<-ddply(subset(meta,snv_qualified==T),~ENROLLID,get_double) # Get those samples that come from longitundal pairs

total.sum<-data.frame(Class=c("Households","Isolates","Individuals","Transmission pairs","Households with potential pairs","Longitudinal sampling"),
                      "All Samples"=c(length(unique(meta$HOUSE_ID)),
                                      nrow(meta),
                                      length(unique(meta$ENROLLID)),
                                      all.sum$total[6],
                                      length(unique(valid_pairs$HOUSE_ID)),
                                      length(unique(all.intra$ENROLLID))),
                      "Sequenced samples"=c(nrow(unique(subset(meta,sequenced==T,select=c(HOUSE_ID)))),
                                            nrow(subset(meta,sequenced==T)),
                                            nrow(unique(subset(meta,sequenced==T,select=c(ENROLLID)))),
                                            sequenced.sum$total[6],
                                            length(unique(sequenced_pairs$HOUSE_ID)),
                                            length(unique(sequenced.intra$ENROLLID))),
                      "Titers1e3" =c(nrow(unique(subset(meta,sequenced==T & gc_ul>1e3,select=c(HOUSE_ID)))),
                                     nrow(subset(meta,sequenced==T & gc_ul>1e3)),
                                     nrow(unique(subset(meta,sequenced==T & gc_ul>1e3,select=c(ENROLLID)))),
                                     snv_hopeful.sum$total[6],
                                     length(unique(snv_hopefull_pairs$HOUSE_ID)),
                                     length(unique(snv_hopefull.intra$ENROLLID))),
                      "SNV sequenced" = c(nrow(unique(subset(meta,snv_qualified==T ,select=c(HOUSE_ID)))),
                                          nrow(subset(meta,snv_qualified==T)),
                                          nrow(unique(subset(meta,snv_qualified==T ,select=c(ENROLLID)))),
                                          paste0(snv.sum$total[6]," (",nrow(subset(all_pairs.tp,valid==T & snv_qualified_pair==T & quality_distance==T)),")"),
                                          length(unique(snv_pairs$HOUSE_ID)),
                                          length(unique(snv.intra$ENROLLID))))
kable(total.sum)
```

```{r}
by_house<-ddply(valid_pairs,~HOUSE_ID+season+pcr_result,summarize,Individuals =length(unique(c(ENROLLID.1,ENROLLID.2))) )
x<-ddply(by_house,~Individuals+season,summarize,households=length(Individuals))

x %>% spread(season,households)->by_house.table

kable(by_house.table)
```
## Looking at transmission

```{r}
one_for_each_plotting<-function(df){
  df$offset_x.1<-min(df$donset) #This puts the points at the onset 
  df$offset_x.2<-max(df$donset) # it used to be offset_x 
  df$offset_y.1<-min(df$offset_y[df$donset==min(df$donset)])  # This needs work
  df$offset_y.2<-max(df$offset_y[df$donset==max(df$donset)])
  return(df[1,])
}
longform_pairs<-function(df){ # This function takes in a data frame with 1 row/ pair and outputs one with 1 row/ enrollid in the pair (ie 2 rows)
  stopifnot(nrow(df)==1) # only 1 row at a time
  House<-df$HOUSE_ID
  season=df$season
  pcr_result<-df$pcr_result
  Enroll1<-df$ENROLLID.1
  Enroll2<-df$ENROLLID.2
  onset.1<-df$onset.1
  onset.2<-df$onset.2
  gc_ul.1<-df$gc_ul.1
  gc_ul.2<-df$gc_ul.2
  pair_id<-df$pair_id
  sequenced.1<-df$sequenced.1
  sequenced.2<-df$sequenced.2
  sequenced_pair<-df$sequenced_pair
  titer_pair<-df$titer_pair
  first.df<-data.frame(HOUSE_ID=House,pair_id=pair_id,ENROLLID=Enroll1,pcr_result=pcr_result,season,onset=onset.1,gc_ul=gc_ul.1,sequenced=sequenced.1,sequenced_pair=sequenced_pair,titer_pair=titer_pair,valid=df$valid,quality_distance=df$quality_distance)
  second.df<-data.frame(HOUSE_ID=House,pair_id=pair_id,ENROLLID=Enroll2,pcr_result=pcr_result,season,onset=onset.2,gc_ul=gc_ul.2,sequenced=sequenced.2,sequenced_pair=sequenced_pair,titer_pair=titer_pair,valid=df$valid,quality_distance=df$quality_distance)
  if(df$onset.1<df$onset.2){
    first.df$case="Donor"
    second.df$case="Recipient"
  }
  if(df$onset.1==df$onset.2){
    first.df$case="Unknown"
    second.df$case="Unknown"
  }
  
  out<-rbind(first.df,second.df)
  return(out)
}

make_transmission_plot<-function(x,type="all"){ # type should be all or valid or invalid.
  stopifnot(type %in% c('all','valid','invalid'))
  x<-adply(x,1,longform_pairs) # Each row is a pair so for each pair split the row into 2 rows 
  x<-subset(x,select=c(HOUSE_ID,pair_id,ENROLLID,pcr_result,season,onset,gc_ul,sequenced,sequenced_pair,titer_pair,snv_qualified_pair,valid,quality_distance)) # just select these columns for each row
  x<-ddply(x,~HOUSE_ID,function(x){ # This will be useful for ording the plotting - at least that's the hope. For each house get the first onset date and set the donset as the distance of each case from that date.
    min_onset<-min(x$onset)
    mutate(x,min_onset=min_onset,donset=onset-min_onset)
  })
  
  
  x<-x[order(x$min_onset,x$HOUSE_ID,decreasing = T),] # I told you it would be useful - based on the first onset in each house.
  HOUSE_order<-unique(x$HOUSE_ID) # This is the order we want the houses to be in on the plot
  
  
  x<-ddply(x,~HOUSE_ID,function(z){
    z$y_Id=which(HOUSE_order==unique(z$HOUSE_ID))*2 # where does this house fall in the order
    return(z)})
  
  
  # I don't really use this any more but it is useful if you want to offset points with the same x value by shifting them on the x axis
  x<- ddply(x, ~onset+y_Id, function(x){ # this applys an offset for different individuals who are sick on the same day
      if(length(unique(x$ENROLLID))>1){ # if there are mulitple people here
      ENROLLIDs<-sort(unique(x$ENROLLID),decreasing=T)
      x<-mutate(x,sort_order=match(ENROLLID,ENROLLIDs)-1,offset_x=as.numeric(donset+sort_order/5))
      }
    else{
      x<-mutate(x,offset_x=as.numeric(donset))
    }
    return(x)
    })
  
   x<- ddply(x, ~onset+y_Id, function(x){ # this applys an offset for different individuals who are sick on the same day
      if(length(unique(x$ENROLLID))>1){ # if there are mulitple people here
      ENROLLIDs<-sort(unique(x$ENROLLID),decreasing=T)
      x<-mutate(x,sort_order=match(ENROLLID,ENROLLIDs)-1,offset_y=y_Id+((-1*length(ENROLLIDs)+4)*sort_order-1))
      }
    else{
      x<-mutate(x,offset_y=y_Id)
    }
    return(x)
    })
  
  
  # Curves and such
  
   # if the onset date is the same for both add a a curve and aline - this will be interpretted as 2 curves later

  x$line=T # start with all lines
  x$curve=F
  x<-ddply(x,~pair_id,function(x){
    if(length(unique(x$onset))==1){ # This pair is sick on the same day # and they are the only ones in the house
      x$curve=T 
      }
    return(x)})

  # If there is point between the two in the pair add a curve and no line
  
  # This is a mess of a block of code. We pass each house grab the y axis. 
  #Then we look at each pair in the house. If the points are separated on 
  #the x axis with another point in between then we get rid of the line 
  #connecting and replace it with a curve
  x<-ddply(x,~HOUSE_ID,function(u){
    offset_y<-sort(unique(u$offset_y))
    ddply(u,~pair_id,function(y,offset_y){
      diff<-which(offset_y %in% y$offset_y)
      #print(diff)
      #stopifnot(length(diff)==2)
      if(length(diff)==2 & abs(diff[1]-diff[2])!=1){ # ie there is a point between these two
        #print(abs(diff[1]-diff[2]))
        y$curve=T
        y$line=F
      }
      #print(y)
      return(y)
    },offset_y)
  })
  
  seasons = ddply(x,~season,summarize,ymin=min(y_Id)-0.25,ymax=max(y_Id)+0.25,middle=mean(y_Id))
  
  if(type=="valid"){
    x<-subset(x,valid==T)
  }
  else if(type=="invalid"){
    x<-subset(x,valid==F)
    x$quality_distance=1 # makes all lines solid otherwise dashed lines represnet those with too big L1-norm

  }else if(type=="all"){
    x$quality_distance=1 # makes all lines solid
  }
  x_useful<-subset(x,snv_qualified_pair==T )
  x_lost<-subset(x,snv_qualified_pair==F) # they were lost either to not sequencing or poor titer or poor sequencing
  
  x_lines_useful<-subset(x_useful,line==T & curve==F)
  x_curves_over_useful<-subset(x_useful,line==F & curve==T)
  x_curves_both_useful<-subset(x_useful,line==T & curve==T)
  

  x_lines_useful<-ddply(x_lines_useful,~pair_id,one_for_each_plotting) # back to short form, 1 row/ pair for the lines.  offset_x is the onsets here. 1 is the first case 2 is the second
  x_curves_over_useful<-ddply(x_curves_over_useful,~pair_id,one_for_each_plotting)
  x_curves_both_useful<-ddply(x_curves_both_useful,~pair_id,one_for_each_plotting)
  
  arrow_length= 0.005
  
  transmission_plot_useful<-ggplot()+ylab("")+xlab("Onset (relative to index case)")+geom_segment(data=seasons,aes(x=-0.5,xend=-0.5,y=ymax,yend=ymin,group=season))+geom_text(data=seasons,aes(x=-1.3,y=middle,label=season,angle=0))
  if(nrow(x_lines_useful)>0){
    transmission_plot_useful<-transmission_plot_useful+geom_segment(data=x_lines_useful,aes(x=offset_x.1,xend=offset_x.2,y=offset_y.1,yend=offset_y.2,group=pair_id,linetype=factor((-2*quality_distance)+3)), # this makes the lines solid if the quality distance ==T and dashed if not
                 arrow = arrow(length = unit(arrow_length, "npc")),
                 color=cbPalette[1])
  }
  if(nrow(x_curves_over_useful)>0){
    transmission_plot_useful<-transmission_plot_useful+geom_curve(data=x_curves_over_useful,aes(x=offset_x.1,xend=offset_x.2,y=offset_y.1,yend=offset_y.2,group=pair_id,linetype=factor((-2*quality_distance)+3)),
               curvature = -0.1,
               arrow = arrow(length = unit(arrow_length, "npc")),
               color=cbPalette[1])
  }
  if(nrow(x_curves_both_useful)>0){
    transmission_plot_useful<-transmission_plot_useful+geom_curve(data=x_curves_both_useful,aes(x=offset_x.1,xend=offset_x.2,y=offset_y.1,yend=offset_y.2,group=pair_id,linetype=factor((-2*quality_distance)+3)),
               curvature = -0.4,
               arrow = arrow(length = unit(arrow_length, "npc")),
               #linetype=2,
               color=cbPalette[1])+
      geom_curve(data=x_curves_both_useful,aes(x=offset_x.2,xend=offset_x.1,y=offset_y.2,yend=offset_y.1,group=pair_id,linetype=factor((-2*quality_distance)+3)),
               curvature = -0.4,
               arrow = arrow(length = unit(arrow_length, "npc")),
               #linetype=2,
               color=cbPalette[1])
  }
  transmission_plot_useful<-transmission_plot_useful+geom_point(data=x_useful,aes(x=as.numeric(donset),y=offset_y),size=0.5)
  if(nrow(x_lost)>0){ # if at least some the data is removed then we'll add the differently colored lines
  x_lines_lost<-subset(x_lost,line==T & curve==F)
  x_curves_over_lost<-subset(x_lost,line==F & curve==T)
  x_curves_both_lost<-subset(x_lost,line==T & curve==T)
  
  # Now we just need one x axis point for each onset in the pair
  x_lines_lost<-ddply(x_lines_lost,~pair_id,one_for_each_plotting)
  x_curves_over_lost<-ddply(x_curves_over_lost,~pair_id,one_for_each_plotting)
  x_curves_both_lost<-ddply(x_curves_both_lost,~pair_id,one_for_each_plotting)
  
    transmission_plot_all<-transmission_plot_useful+geom_point(data=x_lost,aes(x=donset,y=offset_y),size=0.5)+
    geom_segment(data=x_lines_lost,aes(x=offset_x.1,xend=offset_x.2,y=offset_y.1,yend=offset_y.2,group=pair_id),
                 arrow = arrow(length = unit(arrow_length, "npc")),
                 color=cbPalette[4])
    if(nrow(x_curves_over_lost)>0){
    transmission_plot_all<-transmission_plot_all+geom_curve(data=x_curves_over_lost,aes(x=offset_x.1,xend=offset_x.2,y=offset_y.1,yend=offset_y.2,group=pair_id),
               curvature = -0.1,
               arrow = arrow(length = unit(arrow_length, "npc")),
                 color=cbPalette[4])
    }
    if(nrow(x_curves_both_lost)>0){
      transmission_plot_all<- transmission_plot_all+geom_curve(data=x_curves_both_lost,aes(x=offset_x.1,xend=offset_x.2,y=offset_y.1,yend=offset_y.2,group=pair_id),
               curvature = -0.4,
               arrow = arrow(length = unit(arrow_length, "npc")),
               linetype=2,
                 color=cbPalette[4])+
      geom_curve(data=x_curves_both_lost,aes(x=offset_x.2,xend=offset_x.1,y=offset_y.2,yend=offset_y.1,group=pair_id),
               curvature = -0.4,
               arrow = arrow(length = unit(arrow_length, "npc")),
               linetype=2,
                 color=cbPalette[4])+
    ylab("")+xlab("Onset (relative to index case)")
    }
  }  
  else{
    transmission_plot_all<-transmission_plot_useful
  }
return(transmission_plot_all+theme(legend.position = 'none',axis.line.y=element_blank(),axis.ticks.y = element_blank()) +scale_y_continuous(breaks=c())+scale_x_continuous(breaks=c(0:11),limits = c(-1.5,11)))
}
  
```

```{r,fig.align='center',eval=F}
#require(
all_10_11<-make_transmission_plot(subset(all_pairs.tp,season=="10-11"))
all_10_11<-all_10_11+ggtitle("Transmission pairs 2010-2011")
all_10_11

all_11_12<-make_transmission_plot(subset(all_pairs.tp,season=="11-12"))
all_11_12<-all_11_12+ggtitle("Transmission pairs 2011-2012")
all_11_12

all_12_13<-make_transmission_plot(subset(all_pairs.tp,season=="12-13"))
all_12_13<-all_12_13+ggtitle("Transmission pairs 2012-2013")
all_12_13

all_13_14<-make_transmission_plot(subset(all_pairs.tp,season=="13-14"))
all_13_14<-all_13_14+ggtitle("Transmission pairs 2013-2014")
all_13_14

all_14_15<-make_transmission_plot(subset(all_pairs.tp,season=="2014-2015"))
all_14_15<-all_14_15+ggtitle("Transmission pairs 2014-2015")
all_14_15

ggsave("./2010-2011_pairs.pdf",plot=all_10_11,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")
ggsave("./2011-2012_pairs.pdf",plot=all_11_12,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")
ggsave("./2012-2013_pairs.pdf",plot=all_12_13,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")
ggsave("./2013-2014_pairs.pdf",plot=all_13_14,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")
ggsave("./2014-2015_pairs.pdf",plot=all_14_15,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")


```

# Valid pairs
Transmission rules. These apply to all cases where 2 individuals are sick within the same household within a week of eachtoher (difference in date of onset <= 7 days).

In the event of multiple possible donors we assume the donor is the individual with symptom onset neast to the recipeient

The donor and recipeint are never have symptoms on the same day unless they are the only cases in the house. In this case we will randomize the pair and estimate a bottleneck both ways.


We'll take a look at the pairs we are refering to and then get a list of all those that quailify.

```{r,fig.align='center'}
#require(plotly)
# all_10_11<-make_transmission_plot(subset(all_pairs.tp,season=="10-11"),type='valid')
# all_10_11<-all_10_11+ggtitle("2010-2011")
# all_10_11
# 
# all_11_12<-make_transmission_plot(subset(all_pairs.tp,season=="11-12"),type='valid')
# all_11_12<-all_11_12+ggtitle("2011-2012")
# all_11_12
# 
# all_12_13<-make_transmission_plot(subset(all_pairs.tp,season=="12-13"),type='valid')
# all_12_13<-all_12_13+ggtitle("2012-2013")
# all_12_13
# 
# all_13_14<-make_transmission_plot(subset(all_pairs.tp,season=="13-14"),type='valid')
# all_13_14<-all_13_14+ggtitle("2013-2014")
# all_13_14
# 
# all_14_15<-make_transmission_plot(subset(all_pairs.tp,season=="2014-2015"),type='valid')
# all_14_15<-all_14_15+ggtitle("2014-2015")
# all_14_15
# 
# ggsave("./2010-2011_pairs.valid.pdf",plot=all_10_11,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")
# ggsave("./2011-2012_pairs.valid.pdf",plot=all_11_12,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")
# ggsave("./2012-2013_pairs.valid.pdf",plot=all_12_13,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")
# ggsave("./2013-2014_pairs.valid.pdf",plot=all_13_14,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")
# ggsave("./2014-2015_pairs.valid.pdf",plot=all_14_15,device="pdf",path="./Figures/Transmission_pairs/",width=6,height=8,units="in")

all_seasons<-make_transmission_plot(all_pairs.tp,type='valid')

all_seasons

all_seasons_useful<-make_transmission_plot(subset(all_pairs.tp,snv_qualified_pair==T & valid==T),type='valid')
all_seasons_useful

write.csv(subset(all_pairs.tp,snv_qualified_pair==T & valid==T),"Figures/data/Figure3B.csv")

```


Here is a final summary table. These are the valid pairs
```{r,eval=T}
st <- rbind(
  data.frame(all.sum, Group = 'All', what = factor(all.sum$season, levels = all.sum$season), 
             row.names= NULL, check.names = FALSE), 
  data.frame(sequenced.sum,Group = 'Sequenced',what = factor(sequenced.sum$season, levels = sequenced.sum$season), 
             row.names = NULL,check.names = FALSE),
  data.frame(snv_hopeful.sum,Group = 'Titer>1e3',what = factor(snv_hopeful.sum$season, levels = snv_hopeful.sum$season), 
             row.names = NULL,check.names = FALSE),
  data.frame(snv.sum,Group = 'SNV qualified',what = factor(snv.sum$season, levels = snv.sum$season), 
             row.names = NULL,check.names = FALSE)
     )
require(tables)
mytable <- tabular(Heading()*what ~ Group*(`A/H1N1` +`A/H3N2`+`total`)*Heading()*(identity),data=st)
print(mytable)
#latex(mytable)

detach(package:tables)
detach(package:plyr)
library(plyr)
```


# SNV summary




### Titers

There are two samples here with NA DPI, I believe we don't have meta data on when the symptoms began. Also there are two samples with negative DPI. These are all removed in the DPI plots unless otherwise obvious.
```{r,all_titers}
titers<-subset(meta,!(is.na(DPI))) #)& DPI>=0 ) # We only want the titers where we measured a titer ( I beleive there are 2 samples here with NA). Also 2 samples were collected before symptoms - according to the meta data. That's probably a typo so we remove it here.
give.n <- function(x){ # How many samples are in this box of the box plot
  return(c(y = median(x)*1.1, label = length(x))) 
  # experiment with the multiplier to find the perfect position
}

titer.p<-ggplot(titers,aes(x=as.factor(DPI),y=gc_ul))+geom_boxplot(notch = T)+ylab(expression(paste(Genomes,"/" ,mu,L)))+scale_y_log10()+xlab("Days post symptom onset")#+  stat_summary(fun.data = give.n, geom = "text", fun.y = median)
titer.p

write.csv(titers,"./Figures/data/Figure1A.csv")
```
There are warning messages for 13 samples we did not get usable numbers back from the qPCR. They have NA in the log_copy_num column but R gives them 0 in the gc_ul. These are removed on the log scale.



```{r,titer_over_time,eval=F}
intra_titers<-subset(all.intra,!(is.na(DPI)) & DPI>=0 & gc_ul>0) # See text above

#ggplot(intra_titers,aes(x=as.factor(DPI),y=gc_ul,group=ENROLLID))+geom_line()+geom_point()+ylab(expression(paste(genomes,"/" ,mu,L)))+scale_y_log10()+xlab("Days post symptom onset")#+geom_point(position = "jitter")
```

### Frequency distribution
```{r,frequency_distribution}
min.qual<-subset(qual,freq.var<0.5) # only looking at minor alleles
classes<-ddply(min.qual,~class_factor,summarize,mutations=length(mutation)) # class factor is is Nonsym if in any open reading frame the mutation is Nonsym.
kable(classes)
write_to_summary("Ns/S:",
                 classes$mutations[classes$class_factor=="Nonsynonymous"]/classes$mutations[classes$class_factor=="Synonymous"])


freq_hist.p<-ggplot(min.qual,aes(x=freq.var,fill=class_factor))+geom_histogram(color="white",binwidth=.05,position=position_dodge(),boundary = 0.02)+xlab("Frequency")+ylab("iSNV")+scale_fill_manual(name="",values=cbPalette[c(1,4)])+theme(legend.position = c(0.5, 0.5))
freq_hist.p

write.csv(min.qual,"./Figures/data/Figure1C_D.csv")

class.df<-ddply(min.qual,~class_factor,summarize,count = length(mutation))

freq_hist.d<-ggplot_build(freq_hist.p)
freq_hist.d$data[[1]]->bins
bins$bin<-rep(1:10,each=2)
require(magrittr)
bins %>% ddply(~bin,function(x) x$count[2]/x$count[1])->bin_ratio
bin_ratio

write_to_summary("Max Ns/S:",max(bin_ratio$V1))

```


`r class.df$count[class.df$class_factor=="Synonymous"]/sum(class.df$count)`

### Distribution across the genome
```{r,isnv_genome}
min.qual$chr<-factor(min.qual$chr,levels = rev(c("PB2","PB1","PA","HA","NP","NR","M","NS"))) # Set the segments as factors with PB2 on top
chrs<-read.csv("../data/reference/segs.csv",stringsAsFactors = T) # get the start and stop of each OR for each segment (2014-2015 used as reference)

chrs$chr<-factor(chrs$chr,levels=levels(min.qual$chr)) # set factors on the is meta data
genome_loc.p<-ggplot(min.qual,aes(x=pos,y=chr))+geom_point(aes(color=class_factor),shape=108,size=5)+geom_segment(data=chrs,aes(x = start, y = chr, xend = stop, yend = chr))+ylab("")+xlab("")+scale_color_manual(name="",values=cbPalette[c(1,4)])+ theme(axis.ticks =element_blank(),axis.line.x = element_blank(),axis.line.y=element_blank())+scale_x_continuous(breaks=c())+theme(legend.position = "none")
genome_loc.p
```

#### Sliding window geomone
```{r}
snv_chr.help<-function(seg,start,stop,step,window,snv.df){
    # get windows
        window.df<-data.frame(left=seq(from = start,to = stop,by=step))
        window.df$chr<-seg
        window.df<- mutate(window.df,right=left+window)
        snv.df<-subset(snv.df,chr==seg)
        #print(window.df)
        counts<-adply(window.df,1,function(x,snv.df){
                                                    x$iSNV = nrow(subset(snv.df,pos>=x$left & pos<x$right))
                                                    return(x)},snv.df)
        return(counts)
        }


sliding_window_snv<-function(snv.df,window,step,chr.seg){
        isnv_counts<-ddply(chr.seg,~chr,function(x,window,step,snv.df){
                                        snv_chr.help(seg = x$chr,start = x$start,stop = x$stop,window = window,step = step,snv.df=subset(snv.df,chr==x$chr))},window,step,snv.df)
  }       
```



```{r}
sliding_counts<-sliding_window_snv(min.qual,100,1,chrs)
sliding_counts$chr<-factor(sliding_counts$chr,levels = rev(c("PB2","PB1","PA","HA","NP","NR","M","NS")))
sliding_counts$pos<-rowMeans(data.frame(x=sliding_counts$left,y=sliding_counts$right))
genome_slide.p<-ggplot(sliding_counts)+geom_line(aes(x = pos,y=(as.numeric(chr)*2+iSNV/10),group=chr))+geom_segment(data=chrs,aes(x = start, y = as.numeric(chr)*2, xend = stop, yend = as.numeric(chr)*2))+ylab("")+xlab("")+ theme(axis.ticks =element_blank(),axis.line.x = element_blank(),axis.line.y=element_blank())+scale_x_continuous(breaks=c())+theme(legend.position = "none")
genome_slide.p
```
### Distribution across Individuals - using every sample

These will need to be rare in mulitple individuals to show up here at >1
```{r,mutations_per_sample}
give.n.atCount <- function(x){ # How many samples are in this box of the box plot
  return(c(y = length(x)*1.1, label = length(x))) 
  # experiment with the multiplier to find the perfect position
}
min.count<-ddply(min.qual,~chr+pos+var+pcr_result+season,summarize,counts=length(unique(ENROLLID))) # In how many people (ENROLLID) is the muation found. It would have to be minor in both people to count in this plot. The chr pos var is used so that called and infered variants of the same var are counted together.
ggplot(min.count,aes(x=counts))+geom_histogram(color="white",binwidth=1)+xlab("Number of individuals")+ylab("iSNV")+stat_bin(aes(y=..count.., label=..count..), geom="text", vjust=-.5) +scale_y_log10()


min.count %>% subset(counts==1) %>% nrow()->only_once
min.count %>% subset(counts==2) %>% nrow()->only_twice
min.count %>% subset(counts==3) %>% nrow()->only_thrice

write_to_summary("unique iSNV n:",only_once)
write_to_summary("unique iSNV %:",only_once/(only_once+only_twice+only_thrice))
write_to_summary("twice iSNV %:",only_twice/(only_once+only_twice+only_thrice))
write_to_summary("thrice iSNV %:",only_thrice/(only_once+only_twice+only_thrice))
write_to_summary("multiple isolates iSNV n:",only_twice+only_thrice)


min.count<-ddply(min.qual,~chr+pos+var+pcr_result+season+mutation,summarize,counts=length(unique(ENROLLID))) # In how many people (ENROLLID) is the muation found. It would have to be minor in both people to count in this plot. The chr pos var is used so that called and infered variants of the same var are counted together.


```
These are the mutations found in multiple individuals
```{r}
multiple<-subset(min.qual,mutation %in% min.count$mutation[min.count$counts>1])

multiple %>% subset(class_factor=="Nonsynonymous") %>% .$mutation %>%
  unique()->mult.NS
write_to_summary("NS mulitple isolates iSNV n:",paste(mult.NS,collapse = ", "))

ggplot(multiple,aes(x=pos,y=chr))+geom_point(aes(color=class_factor),shape=108,size=5)+geom_segment(data=chrs,aes(x = start, y = chr, xend = stop, yend = chr))+ylab("")+xlab("")+scale_color_manual(name="",values=cbPalette[c(1,4)])+ theme(axis.ticks =element_blank(),axis.line.x = element_blank(),axis.line.y=element_blank())+scale_x_continuous(breaks=c())+theme(legend.position = "none")

genome_loc.p.dots<-genome_loc.p + geom_point(data = multiple, aes(x=pos,y=as.numeric(chr)+0.3,color=class_factor),size=1,shape=6)
genome_loc.p.dots
```
These counts don't sum to the total above, but that is because this is looking at individuals above is looking at all sequenced samples (multiple/person) sometimes. If I sum these counts over SPECID then the sums are equal.

### Diversity in samples

```{r,snv_sample}
min.count<-ddply(min.qual,~SPECID,summarize,iSNV=length(unique(mutation)),HA_iSNV=length(which(chr=="HA"))) # How many rare mutations in the sample (SPECID)

snv_qual_meta<-subset(meta,snv_qualified==T)
snv_qual_meta<-join(snv_qual_meta,min.count,by="SPECID")

snv_qual_meta$iSNV[is.na(snv_qual_meta$iSNV)]<-0 # these are the ones with no diversity
snv_qual_meta$HA_iSNV[is.na(snv_qual_meta$HA_iSNV)]<-0

plot.median <- function(x) {
  m <- median(x)
  c(y = m, ymin = m, ymax = m)
}

ggplot(snv_qual_meta,aes(y=iSNV,x=as.factor(vaccination_status)))+geom_dotplot(stackdir = "center",binaxis = 'y',binwidth = 1,dotsize = 0.5)+stat_summary(fun.data="plot.median", geom="errorbar", colour="black", width=0.95, size=0.5)+scale_x_discrete(labels=c("Not Vaccinated","Vaccinated"))+xlab("")

#wilcox.test(snv_qual_meta$iSNV~snv_qual_meta$vaccination_status) 
```

### Distribution of snv in samples (Could be multiple samples/person)

```{r}
quantile(snv_qual_meta$iSNV)->iSNV_quantile
iSNV_quantile
mean(snv_qual_meta$iSNV)

nrow(subset(snv_qual_meta,iSNV<10 & snv_qualified==T)) ->less_10
nrow(subset(snv_qual_meta,iSNV>10 & snv_qualified==T)) -> greater_10

write_to_summary("SPECID <10 iSNV:",less_10)
write_to_summary("SPECID more 10 iSNV:",greater_10)
write_to_summary("Median iSNV:",paste(iSNV_quantile[3],collapse = ""))
write_to_summary("IQR iSNV:",paste(iSNV_quantile[2],iSNV_quantile[4],collapse = "-"))
```


```{r}
isnv_vaccination<-ggplot(snv_qual_meta,aes(y=iSNV,x=as.factor(vaccination_status)))+geom_dotplot(stackdir = "center",binaxis = 'y',binwidth = 1,dotsize = 0.5)+stat_summary(fun.data="plot.median", geom="errorbar", colour="red", width=0.5, size=0.5) +xlab("") + scale_x_discrete(labels = c("Not vaccinated","Vaccinated"))
isnv_vaccination
#wilcox.test(snv_qual_meta$HA_iSNV~snv_qual_meta$vaccination_status) 

```

```{r}
isnv_by_day.p<-ggplot(snv_qual_meta,aes(x=as.factor(DPI),y=iSNV))+geom_boxplot()+xlab("Day post symptom onset")#+geom_dotplot(stackdir = "center",binaxis = 'y',binwidth = 1,dotsize = 0.5)+stat_summary(fun.data="plot.median", geom="errorbar", colour="black", width=0.95, size=0.5)
write.csv(snv_qual_meta,"./Figures/data/Figure1B.csv")

isnv_by_day.p
ggplot(snv_qual_meta,aes(x=as.factor(pcr_result),y=iSNV))+geom_dotplot(stackdir = "center",binaxis = 'y',binwidth = 1,dotsize = 0.5)+stat_summary(fun.data="plot.median", geom="errorbar", colour="black", width=0.95, size=0.5)+xlab("Strain")

isnv_titer<-ggplot(snv_qual_meta,aes(x=gc_ul,y=iSNV))+geom_point()+scale_x_log10()+xlab(expression(paste(Genomes,"/" ,mu,L)))
isnv_titer
```

# Figure 1

```{r}
require(cowplot)

fig_1<-plot_grid(titer.p,isnv_by_day.p,freq_hist.p, genome_loc.p, labels = c("A", "B", "C", "D"), ncol = 2,align = c("v","h"))#+draw_label("DRAFT!", angle = 45, size = 80, alpha = .2)

save_plot("./Figures/Figure1.pdf", fig_1,
          ncol = 2, # we're saving a grid plot of 2 columns
          nrow = 2, # and 2 rows
          # each individual subplot should have an aspect ratio of 1.3
          base_aspect_ratio = 1.3
          )
embed_fonts("./Figures/Figure1.pdf")
fig_1
```


Separate Panels

```{r}
save_plot("./Figures/Figure1A.pdf", titer.p,
          base_aspect_ratio = 1.3)
embed_fonts("./Figures/Figure1A.pdf")
#titer.pg<-ggplot_build(titer.p)

save_plot("./Figures/Figure1B.pdf", isnv_by_day.p,
          base_aspect_ratio = 1.3)
embed_fonts("./Figures/Figure1B.pdf")

save_plot("./Figures/Figure1C.pdf", freq_hist.p,
          base_aspect_ratio = 1.3)

embed_fonts("./Figures/Figure1C.pdf")
save_plot("./Figures/Figure1D.pdf", genome_loc.p,
          base_aspect_ratio = 1.3)

save_plot("./Figures/Figure1D2.pdf", genome_loc.p.dots,
          base_aspect_ratio = 1.3)
embed_fonts("./Figures/Figure1D2.pdf")

```


# Figure 3
```{r}
fig_3<-plot_grid(l1norm.p_tp,all_seasons_useful , labels = c("A", "B"), ncol = 1,align = c("h"),rel_heights=c(1,3))#+draw_label("DRAFT!", angle = 45, size = 80, alpha = .2)

save_plot("./Figures/Figure3.pdf", fig_3,
          ncol = 1, # we're saving a grid plot of 1 columns
          nrow = 2, # and 2 rows
          base_height = 6,
          # each individual subplot should have an aspect ratio of 1.3
          base_aspect_ratio = 1.3
          )
embed_fonts("./Figures/Figure3.pdf")
fig_3

```

```{r}
save_plot("./Figures/Figure3A.pdf", l1norm.p_tp,
          base_aspect_ratio = 1.3,
          base_height = 6)
embed_fonts("./Figures/Figure3A.pdf")

save_plot("./Figures/Figure3B.pdf", all_seasons_useful,
          base_aspect_ratio = 1.3,
          base_height = 6)
embed_fonts("./Figures/Figure3b.pdf")

```

```{r}
write.csv(all_pairs.tp,"./transmission_pairs.csv")
```

#Supplemental Figure 3

```{r}
sup_fig_1<-plot_grid(isnv_titer,isnv_vaccination, labels = c("A", "B"), ncol = 2,align = c("v","h"))#+draw_label("DRAFT!", angle = 45, size = 80, alpha = .2)

save_plot("./Figures/Supplemental_Figure3.pdf", sup_fig_1,
          ncol = 2, # we're saving a grid plot of 2 columns
          nrow = 1, # and 1 row
          # each individual subplot should have an aspect ratio of 1.3
          base_aspect_ratio = 1.3
          )
embed_fonts("./Figures/Supplemental_Figure3.pdf")
sup_fig_1
```

```{r}
write.csv(x = snv_qual_meta,"../data/meta_snv_qual.csv")
```

# Looking at the outliers

Let's take a look at the samples with many snv.


```{r}

require(ggjoy)
outliers<-subset(min.count,iSNV>10)

outliers.snv<-subset(min.qual,SPECID %in% outliers$SPECID)

ggplot(outliers.snv,aes(x=freq.var))+geom_histogram(aes(fill=SPECID),position='dodge',binwidth = 0.05)#+scale_fill_manual(values=wes_palette("GrandBudapest2"))
ggplot(outliers.snv,aes(x=freq.var,y= as.factor(SPECID),height = ..density..))+geom_joy(scale = 4)
```
This looks like mixed infections. We find many mutations at similar frequencies.




### Intrahost set up
```{r}
source("../scripts/useful_functions.R")
```


```{r}
intra<-ddply(snv.intra,~ENROLLID,function(x){
  x<-x[(order(c(x$collect),decreasing = F)),]
  HOUSE_ID=unique(x$HOUSE_ID)
  ENROLLID = unique(x$ENROLLID)
  season=unique(x$season)
  onset = unique(x$onset)
  SPECID.1 = x$SPECID[1]
  SPECID.2 = x$SPECID[2]
  gc_ul.1 = x$gc_ul[1]
  gc_ul.2 = x$gc_ul[2]

  return(data.frame(HOUSE_ID=HOUSE_ID,ENROLLID=ENROLLID,season=season,onset=onset,SPECID.1=SPECID.1,SPECID.2=SPECID.2,gc_ul.1=gc_ul.1,gc_ul.2=gc_ul.2))
  })

intra_freq<-adply(intra,1,function(x) get_freqs(x,qual)) # Make the comparision

intra_freq<-subset(intra_freq,!(is.na(mutation)))

```

```{r,intrahost_sum}
intra_freq<-mutate(intra_freq,within_host_time=meta$collect[match(SPECID.2,meta$SPECID)]-meta$collect[match(SPECID.1,meta$SPECID)])
just_one<-ddply(intra_freq,~SPECID.1+SPECID.2,summarize,within_host_time=unique(within_host_time)) # Just get one within_host_time/ pair

intra_time.p<-ggplot(just_one,aes(x=within_host_time))+geom_histogram(binwidth =1, color="white")+xlab("Days between samples")+ ylab("Sample Pairs")+stat_bin(aes(y=..count.., label=..count..), binwidth = 1,geom="text", vjust=-.5)
intra_time.p
#ggsave("./intra_time_dist.png",intra_time.p)

```


We are only looking at polymorphic sites between 2% and 98%.


```{r,intrahost_maintaince}
intra_freq.comp<-subset(intra_freq,freq1>0) 
intra_freq.comp<-subset(intra_freq,freq1>0.02 & freq1<0.98)
intra_freq.comp<-ddply(intra_freq.comp,~chr+pos+SPECID.1,function(x) if(nrow(x)>1){return(x)}) # only polymorphic sites in sample 1 
# Now if one of the freq2 at a given site is <1.5% we must set the other to 1 in order to treat the first and second samples equally.

intra_freq.comp<-ddply(intra_freq.comp,~chr+pos+SPECID.2, function(x){
  if(min(x$freq2<0.02)){
    stopifnot(max(x$freq2)>0.98) # This is to make sure we are not setting a major allele to 1 when the major allele is in the polymorphic range - This could happen given some of the pecularieties with the allelic frequencies and deepSNV (i.e. There may be some sequencing errors that make up the missing frequencies)
    x$freq2[x$freq2==max(x$freq2)]<-1
    x$freq2[x$freq2==min(x$freq2)]<-0
  }
  return(x)
})
intra_freq.comp<-adply(intra_freq.comp,1,function(x){
  donor_class = subset(qual,SPECID==x$SPECID.1[1] & mutation == x$mutation[1],select=c(class_factor))
  #print(x)
  x$donor_class = as.character(donor_class$class_factor)
  return(x)
})
write.csv(x = intra_freq,"./Intrahost_all.csv")

write.csv(x = intra_freq.comp,"./Intrahost_initially_present.csv")
```